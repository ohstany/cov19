{"ast":null,"code":"/* Copyright 2015 William Summers, MetaTribal LLC\n * adapted from https://developer.mozilla.org/en-US/docs/JXON\n *\n * Licensed under the MIT License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/MIT\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @author William Summers\n *\n */\nvar xmlToJSON = function () {\n  this.version = \"1.3.4\";\n  var options = {\n    // set up the default options\n    mergeCDATA: true,\n    // extract cdata and merge with text\n    grokAttr: true,\n    // convert truthy attributes to boolean, etc\n    grokText: true,\n    // convert truthy text/attr to boolean, etc\n    normalize: true,\n    // collapse multiple spaces to single space\n    xmlns: true,\n    // include namespaces as attribute in output\n    namespaceKey: \"_ns\",\n    // tag name for namespace objects\n    textKey: \"_text\",\n    // tag name for text nodes\n    valueKey: \"_value\",\n    // tag name for attribute values\n    attrKey: \"_attr\",\n    // tag for attr groups\n    cdataKey: \"_cdata\",\n    // tag for cdata nodes (ignored if mergeCDATA is true)\n    attrsAsObject: true,\n    // if false, key is used as prefix to name, set prefix to '' to merge children and attrs.\n    stripAttrPrefix: true,\n    // remove namespace prefixes from attributes\n    stripElemPrefix: true,\n    // for elements of same name in diff namespaces, you can enable namespaces and access the nskey property\n    childrenAsArray: true // force children into arrays\n\n  };\n  var prefixMatch = new RegExp(/(?!xmlns)^.*:/);\n  var trimMatch = new RegExp(/^\\s+|\\s+$/g);\n\n  this.grokType = function (sValue) {\n    if (/^\\s*$/.test(sValue)) {\n      return null;\n    }\n\n    if (/^(?:true|false)$/i.test(sValue)) {\n      return sValue.toLowerCase() === \"true\";\n    }\n\n    if (isFinite(sValue)) {\n      return parseFloat(sValue);\n    }\n\n    return sValue;\n  };\n\n  this.parseString = function (xmlString, opt) {\n    return this.parseXML(this.stringToXML(xmlString), opt);\n  };\n\n  this.parseXML = function (oXMLParent, opt) {\n    // initialize options\n    for (var key in opt) {\n      options[key] = opt[key];\n    }\n\n    var vResult = {},\n        nLength = 0,\n        sCollectedTxt = \"\"; // parse namespace information\n\n    if (options.xmlns && oXMLParent.namespaceURI) {\n      vResult[options.namespaceKey] = oXMLParent.namespaceURI;\n    } // parse attributes\n    // using attributes property instead of hasAttributes method to support older browsers\n\n\n    if (oXMLParent.attributes && oXMLParent.attributes.length > 0) {\n      var vAttribs = {};\n\n      for (nLength; nLength < oXMLParent.attributes.length; nLength++) {\n        var oAttrib = oXMLParent.attributes.item(nLength);\n        var vContent = {};\n        var attribName = \"\";\n\n        if (options.stripAttrPrefix) {\n          attribName = oAttrib.name.replace(prefixMatch, \"\");\n        } else {\n          attribName = oAttrib.name;\n        }\n\n        if (options.grokAttr) {\n          vContent[options.valueKey] = this.grokType(oAttrib.value.replace(trimMatch, \"\"));\n        } else {\n          vContent[options.valueKey] = oAttrib.value.replace(trimMatch, \"\");\n        }\n\n        if (options.xmlns && oAttrib.namespaceURI) {\n          vContent[options.namespaceKey] = oAttrib.namespaceURI;\n        }\n\n        if (options.attrsAsObject) {\n          // attributes with same local name must enable prefixes\n          vAttribs[attribName] = vContent;\n        } else {\n          vResult[options.attrKey + attribName] = vContent;\n        }\n      }\n\n      if (options.attrsAsObject) {\n        vResult[options.attrKey] = vAttribs;\n      } else {}\n    } // iterate over the children\n\n\n    if (oXMLParent.hasChildNodes()) {\n      for (var oNode, sProp, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {\n        oNode = oXMLParent.childNodes.item(nItem);\n\n        if (oNode.nodeType === 4) {\n          if (options.mergeCDATA) {\n            sCollectedTxt += oNode.nodeValue;\n          } else {\n            if (vResult.hasOwnProperty(options.cdataKey)) {\n              if (vResult[options.cdataKey].constructor !== Array) {\n                vResult[options.cdataKey] = [vResult[options.cdataKey]];\n              }\n\n              vResult[options.cdataKey].push(oNode.nodeValue);\n            } else {\n              if (options.childrenAsArray) {\n                vResult[options.cdataKey] = [];\n                vResult[options.cdataKey].push(oNode.nodeValue);\n              } else {\n                vResult[options.cdataKey] = oNode.nodeValue;\n              }\n            }\n          }\n        }\n        /* nodeType is \"CDATASection\" (4) */\n        else if (oNode.nodeType === 3) {\n            sCollectedTxt += oNode.nodeValue;\n          }\n          /* nodeType is \"Text\" (3) */\n          else if (oNode.nodeType === 1) {\n              /* nodeType is \"Element\" (1) */\n              if (nLength === 0) {\n                vResult = {};\n              } // using nodeName to support browser (IE) implementation with no 'localName' property\n\n\n              if (options.stripElemPrefix) {\n                sProp = oNode.nodeName.replace(prefixMatch, \"\");\n              } else {\n                sProp = oNode.nodeName;\n              }\n\n              vContent = xmlToJSON.parseXML(oNode);\n\n              if (vResult.hasOwnProperty(sProp)) {\n                if (vResult[sProp].constructor !== Array) {\n                  vResult[sProp] = [vResult[sProp]];\n                }\n\n                vResult[sProp].push(vContent);\n              } else {\n                if (options.childrenAsArray) {\n                  vResult[sProp] = [];\n                  vResult[sProp].push(vContent);\n                } else {\n                  vResult[sProp] = vContent;\n                }\n\n                nLength++;\n              }\n            }\n      }\n    } else if (!sCollectedTxt) {\n      // no children and no text, return null\n      if (options.childrenAsArray) {\n        vResult[options.textKey] = [];\n        vResult[options.textKey].push(null);\n      } else {\n        vResult[options.textKey] = null;\n      }\n    }\n\n    if (sCollectedTxt) {\n      if (options.grokText) {\n        var value = this.grokType(sCollectedTxt.replace(trimMatch, \"\"));\n\n        if (value !== null && value !== undefined) {\n          vResult[options.textKey] = value;\n        }\n      } else if (options.normalize) {\n        vResult[options.textKey] = sCollectedTxt.replace(trimMatch, \"\").replace(/\\s+/g, \" \");\n      } else {\n        vResult[options.textKey] = sCollectedTxt.replace(trimMatch, \"\");\n      }\n    }\n\n    return vResult;\n  }; // Convert xmlDocument to a string\n  // Returns null on failure\n\n\n  this.xmlToString = function (xmlDoc) {\n    try {\n      var xmlString = xmlDoc.xml ? xmlDoc.xml : new XMLSerializer().serializeToString(xmlDoc);\n      return xmlString;\n    } catch (err) {\n      return null;\n    }\n  }; // Convert a string to XML Node Structure\n  // Returns null on failure\n\n\n  this.stringToXML = function (xmlString) {\n    try {\n      var xmlDoc = null;\n\n      if (window.DOMParser) {\n        var parser = new DOMParser();\n        xmlDoc = parser.parseFromString(xmlString, \"text/xml\");\n        return xmlDoc;\n      } else {\n        //xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n        xmlDoc.async = false;\n        xmlDoc.loadXML(xmlString);\n        return xmlDoc;\n      }\n    } catch (e) {\n      return null;\n    }\n  };\n\n  return this;\n}.call({});\n\nif (typeof module != \"undefined\" && module !== null && module.exports) module.exports = xmlToJSON;","map":null,"metadata":{},"sourceType":"script"}