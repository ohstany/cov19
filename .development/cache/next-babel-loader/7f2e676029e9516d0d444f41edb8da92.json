{"ast":null,"code":"/* Copyright 2015 William Summers, MetaTribal LLC\n * adapted from https://developer.mozilla.org/en-US/docs/JXON\n *\n * Licensed under the MIT License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/MIT\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @author William Summers\n *\n */\nvar xmlToJSON = function () {\n  this.version = \"1.3.4\";\n  var options = {\n    // set up the default options\n    mergeCDATA: true,\n    // extract cdata and merge with text\n    grokAttr: true,\n    // convert truthy attributes to boolean, etc\n    grokText: true,\n    // convert truthy text/attr to boolean, etc\n    normalize: true,\n    // collapse multiple spaces to single space\n    xmlns: true,\n    // include namespaces as attribute in output\n    namespaceKey: \"_ns\",\n    // tag name for namespace objects\n    textKey: \"_text\",\n    // tag name for text nodes\n    valueKey: \"_value\",\n    // tag name for attribute values\n    attrKey: \"_attr\",\n    // tag for attr groups\n    cdataKey: \"_cdata\",\n    // tag for cdata nodes (ignored if mergeCDATA is true)\n    attrsAsObject: true,\n    // if false, key is used as prefix to name, set prefix to '' to merge children and attrs.\n    stripAttrPrefix: true,\n    // remove namespace prefixes from attributes\n    stripElemPrefix: true,\n    // for elements of same name in diff namespaces, you can enable namespaces and access the nskey property\n    childrenAsArray: true // force children into arrays\n\n  };\n  var prefixMatch = new RegExp(/(?!xmlns)^.*:/);\n  var trimMatch = new RegExp(/^\\s+|\\s+$/g);\n\n  this.grokType = function (sValue) {\n    if (/^\\s*$/.test(sValue)) {\n      return null;\n    }\n\n    if (/^(?:true|false)$/i.test(sValue)) {\n      return sValue.toLowerCase() === \"true\";\n    }\n\n    if (isFinite(sValue)) {\n      return parseFloat(sValue);\n    }\n\n    return sValue;\n  };\n\n  this.parseString = function (xmlString, opt) {\n    return this.parseXML(this.stringToXML(xmlString), opt);\n  };\n\n  this.parseXML = function (oXMLParent, opt) {\n    // initialize options\n    for (var key in opt) {\n      options[key] = opt[key];\n    }\n\n    var vResult = {},\n        nLength = 0,\n        sCollectedTxt = \"\"; // parse namespace information\n\n    if (options.xmlns && oXMLParent.namespaceURI) {\n      vResult[options.namespaceKey] = oXMLParent.namespaceURI;\n    } // parse attributes\n    // using attributes property instead of hasAttributes method to support older browsers\n\n\n    if (oXMLParent.attributes && oXMLParent.attributes.length > 0) {\n      var vAttribs = {};\n\n      for (nLength; nLength < oXMLParent.attributes.length; nLength++) {\n        var oAttrib = oXMLParent.attributes.item(nLength);\n        var vContent = {};\n        var attribName = \"\";\n\n        if (options.stripAttrPrefix) {\n          attribName = oAttrib.name.replace(prefixMatch, \"\");\n        } else {\n          attribName = oAttrib.name;\n        }\n\n        if (options.grokAttr) {\n          vContent[options.valueKey] = this.grokType(oAttrib.value.replace(trimMatch, \"\"));\n        } else {\n          vContent[options.valueKey] = oAttrib.value.replace(trimMatch, \"\");\n        }\n\n        if (options.xmlns && oAttrib.namespaceURI) {\n          vContent[options.namespaceKey] = oAttrib.namespaceURI;\n        }\n\n        if (options.attrsAsObject) {\n          // attributes with same local name must enable prefixes\n          vAttribs[attribName] = vContent;\n        } else {\n          vResult[options.attrKey + attribName] = vContent;\n        }\n      }\n\n      if (options.attrsAsObject) {\n        vResult[options.attrKey] = vAttribs;\n      } else {}\n    } // iterate over the children\n\n\n    if (oXMLParent.hasChildNodes()) {\n      for (var oNode, sProp, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {\n        oNode = oXMLParent.childNodes.item(nItem);\n\n        if (oNode.nodeType === 4) {\n          if (options.mergeCDATA) {\n            sCollectedTxt += oNode.nodeValue;\n          } else {\n            if (vResult.hasOwnProperty(options.cdataKey)) {\n              if (vResult[options.cdataKey].constructor !== Array) {\n                vResult[options.cdataKey] = [vResult[options.cdataKey]];\n              }\n\n              vResult[options.cdataKey].push(oNode.nodeValue);\n            } else {\n              if (options.childrenAsArray) {\n                vResult[options.cdataKey] = [];\n                vResult[options.cdataKey].push(oNode.nodeValue);\n              } else {\n                vResult[options.cdataKey] = oNode.nodeValue;\n              }\n            }\n          }\n        }\n        /* nodeType is \"CDATASection\" (4) */\n        else if (oNode.nodeType === 3) {\n            sCollectedTxt += oNode.nodeValue;\n          }\n          /* nodeType is \"Text\" (3) */\n          else if (oNode.nodeType === 1) {\n              /* nodeType is \"Element\" (1) */\n              if (nLength === 0) {\n                vResult = {};\n              } // using nodeName to support browser (IE) implementation with no 'localName' property\n\n\n              if (options.stripElemPrefix) {\n                sProp = oNode.nodeName.replace(prefixMatch, \"\");\n              } else {\n                sProp = oNode.nodeName;\n              }\n\n              vContent = xmlToJSON.parseXML(oNode);\n\n              if (vResult.hasOwnProperty(sProp)) {\n                if (vResult[sProp].constructor !== Array) {\n                  vResult[sProp] = [vResult[sProp]];\n                }\n\n                vResult[sProp].push(vContent);\n              } else {\n                if (options.childrenAsArray) {\n                  vResult[sProp] = [];\n                  vResult[sProp].push(vContent);\n                } else {\n                  vResult[sProp] = vContent;\n                }\n\n                nLength++;\n              }\n            }\n      }\n    } else if (!sCollectedTxt) {\n      // no children and no text, return null\n      if (options.childrenAsArray) {\n        vResult[options.textKey] = [];\n        vResult[options.textKey].push(null);\n      } else {\n        vResult[options.textKey] = null;\n      }\n    }\n\n    if (sCollectedTxt) {\n      if (options.grokText) {\n        var value = this.grokType(sCollectedTxt.replace(trimMatch, \"\"));\n\n        if (value !== null && value !== undefined) {\n          vResult[options.textKey] = value;\n        }\n      } else if (options.normalize) {\n        vResult[options.textKey] = sCollectedTxt.replace(trimMatch, \"\").replace(/\\s+/g, \" \");\n      } else {\n        vResult[options.textKey] = sCollectedTxt.replace(trimMatch, \"\");\n      }\n    }\n\n    return vResult;\n  }; // Convert xmlDocument to a string\n  // Returns null on failure\n\n\n  this.xmlToString = function (xmlDoc) {\n    try {\n      var xmlString = xmlDoc.xml ? xmlDoc.xml : new XMLSerializer().serializeToString(xmlDoc);\n      return xmlString;\n    } catch (err) {\n      return null;\n    }\n  }; // Convert a string to XML Node Structure\n  // Returns null on failure\n\n\n  this.stringToXML = function (xmlString) {\n    try {\n      var xmlDoc = null;\n\n      if (window.DOMParser) {\n        var parser = new DOMParser();\n        xmlDoc = parser.parseFromString(xmlString, \"text/xml\");\n        return xmlDoc;\n      } else {\n        //xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n        xmlDoc.async = false;\n        xmlDoc.loadXML(xmlString);\n        return xmlDoc;\n      }\n    } catch (e) {\n      return null;\n    }\n  };\n\n  return this;\n}.call({});\n\nif (typeof module != \"undefined\" && module !== null && module.exports) module.exports = xmlToJSON;","map":{"version":3,"sources":["/Users/stanislavohstany/WebApps/DEV/coronamap/templates/xmlToJson.js"],"names":["xmlToJSON","version","options","mergeCDATA","grokAttr","grokText","normalize","xmlns","namespaceKey","textKey","valueKey","attrKey","cdataKey","attrsAsObject","stripAttrPrefix","stripElemPrefix","childrenAsArray","prefixMatch","RegExp","trimMatch","grokType","sValue","test","toLowerCase","isFinite","parseFloat","parseString","xmlString","opt","parseXML","stringToXML","oXMLParent","key","vResult","nLength","sCollectedTxt","namespaceURI","attributes","length","vAttribs","oAttrib","item","vContent","attribName","name","replace","value","hasChildNodes","oNode","sProp","nItem","childNodes","nodeType","nodeValue","hasOwnProperty","constructor","Array","push","nodeName","undefined","xmlToString","xmlDoc","xml","XMLSerializer","serializeToString","err","window","DOMParser","parser","parseFromString","async","loadXML","e","call","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAeA;;;;AAKA,IAAIA,SAAS,GAAG,YAAW;AAC1B,OAAKC,OAAL,GAAe,OAAf;AAEA,MAAIC,OAAO,GAAG;AACb;AACAC,IAAAA,UAAU,EAAE,IAFC;AAEK;AAClBC,IAAAA,QAAQ,EAAE,IAHG;AAGG;AAChBC,IAAAA,QAAQ,EAAE,IAJG;AAIG;AAChBC,IAAAA,SAAS,EAAE,IALE;AAKI;AACjBC,IAAAA,KAAK,EAAE,IANM;AAMA;AACbC,IAAAA,YAAY,EAAE,KAPD;AAOQ;AACrBC,IAAAA,OAAO,EAAE,OARI;AAQK;AAClBC,IAAAA,QAAQ,EAAE,QATG;AASO;AACpBC,IAAAA,OAAO,EAAE,OAVI;AAUK;AAClBC,IAAAA,QAAQ,EAAE,QAXG;AAWO;AACpBC,IAAAA,aAAa,EAAE,IAZF;AAYQ;AACrBC,IAAAA,eAAe,EAAE,IAbJ;AAaU;AACvBC,IAAAA,eAAe,EAAE,IAdJ;AAcU;AACvBC,IAAAA,eAAe,EAAE,IAfJ,CAeS;;AAfT,GAAd;AAkBA,MAAIC,WAAW,GAAG,IAAIC,MAAJ,CAAW,eAAX,CAAlB;AACA,MAAIC,SAAS,GAAG,IAAID,MAAJ,CAAW,YAAX,CAAhB;;AAEA,OAAKE,QAAL,GAAgB,UAASC,MAAT,EAAiB;AAChC,QAAI,QAAQC,IAAR,CAAaD,MAAb,CAAJ,EAA0B;AACzB,aAAO,IAAP;AACA;;AACD,QAAI,oBAAoBC,IAApB,CAAyBD,MAAzB,CAAJ,EAAsC;AACrC,aAAOA,MAAM,CAACE,WAAP,OAAyB,MAAhC;AACA;;AACD,QAAIC,QAAQ,CAACH,MAAD,CAAZ,EAAsB;AACrB,aAAOI,UAAU,CAACJ,MAAD,CAAjB;AACA;;AACD,WAAOA,MAAP;AACA,GAXD;;AAaA,OAAKK,WAAL,GAAmB,UAASC,SAAT,EAAoBC,GAApB,EAAyB;AAC3C,WAAO,KAAKC,QAAL,CAAc,KAAKC,WAAL,CAAiBH,SAAjB,CAAd,EAA2CC,GAA3C,CAAP;AACA,GAFD;;AAIA,OAAKC,QAAL,GAAgB,UAASE,UAAT,EAAqBH,GAArB,EAA0B;AACzC;AACA,SAAK,IAAII,GAAT,IAAgBJ,GAAhB,EAAqB;AACpB1B,MAAAA,OAAO,CAAC8B,GAAD,CAAP,GAAeJ,GAAG,CAACI,GAAD,CAAlB;AACA;;AAED,QAAIC,OAAO,GAAG,EAAd;AAAA,QACCC,OAAO,GAAG,CADX;AAAA,QAECC,aAAa,GAAG,EAFjB,CANyC,CAUzC;;AACA,QAAIjC,OAAO,CAACK,KAAR,IAAiBwB,UAAU,CAACK,YAAhC,EAA8C;AAC7CH,MAAAA,OAAO,CAAC/B,OAAO,CAACM,YAAT,CAAP,GAAgCuB,UAAU,CAACK,YAA3C;AACA,KAbwC,CAezC;AACA;;;AACA,QAAIL,UAAU,CAACM,UAAX,IAAyBN,UAAU,CAACM,UAAX,CAAsBC,MAAtB,GAA+B,CAA5D,EAA+D;AAC9D,UAAIC,QAAQ,GAAG,EAAf;;AAEA,WAAKL,OAAL,EAAcA,OAAO,GAAGH,UAAU,CAACM,UAAX,CAAsBC,MAA9C,EAAsDJ,OAAO,EAA7D,EAAiE;AAChE,YAAIM,OAAO,GAAGT,UAAU,CAACM,UAAX,CAAsBI,IAAtB,CAA2BP,OAA3B,CAAd;AACA,YAAIQ,QAAQ,GAAG,EAAf;AACA,YAAIC,UAAU,GAAG,EAAjB;;AAEA,YAAIzC,OAAO,CAACY,eAAZ,EAA6B;AAC5B6B,UAAAA,UAAU,GAAGH,OAAO,CAACI,IAAR,CAAaC,OAAb,CAAqB5B,WAArB,EAAkC,EAAlC,CAAb;AACA,SAFD,MAEO;AACN0B,UAAAA,UAAU,GAAGH,OAAO,CAACI,IAArB;AACA;;AAED,YAAI1C,OAAO,CAACE,QAAZ,EAAsB;AACrBsC,UAAAA,QAAQ,CAACxC,OAAO,CAACQ,QAAT,CAAR,GAA6B,KAAKU,QAAL,CAC5BoB,OAAO,CAACM,KAAR,CAAcD,OAAd,CAAsB1B,SAAtB,EAAiC,EAAjC,CAD4B,CAA7B;AAGA,SAJD,MAIO;AACNuB,UAAAA,QAAQ,CAACxC,OAAO,CAACQ,QAAT,CAAR,GAA6B8B,OAAO,CAACM,KAAR,CAAcD,OAAd,CAC5B1B,SAD4B,EAE5B,EAF4B,CAA7B;AAIA;;AAED,YAAIjB,OAAO,CAACK,KAAR,IAAiBiC,OAAO,CAACJ,YAA7B,EAA2C;AAC1CM,UAAAA,QAAQ,CAACxC,OAAO,CAACM,YAAT,CAAR,GAAiCgC,OAAO,CAACJ,YAAzC;AACA;;AAED,YAAIlC,OAAO,CAACW,aAAZ,EAA2B;AAC1B;AACA0B,UAAAA,QAAQ,CAACI,UAAD,CAAR,GAAuBD,QAAvB;AACA,SAHD,MAGO;AACNT,UAAAA,OAAO,CAAC/B,OAAO,CAACS,OAAR,GAAkBgC,UAAnB,CAAP,GAAwCD,QAAxC;AACA;AACD;;AAED,UAAIxC,OAAO,CAACW,aAAZ,EAA2B;AAC1BoB,QAAAA,OAAO,CAAC/B,OAAO,CAACS,OAAT,CAAP,GAA2B4B,QAA3B;AACA,OAFD,MAEO,CACN;AACD,KA1DwC,CA4DzC;;;AACA,QAAIR,UAAU,CAACgB,aAAX,EAAJ,EAAgC;AAC/B,WACC,IAAIC,KAAJ,EAAWC,KAAX,EAAkBC,KAAK,GAAG,CAD3B,EAECA,KAAK,GAAGnB,UAAU,CAACoB,UAAX,CAAsBb,MAF/B,EAGCY,KAAK,EAHN,EAIE;AACDF,QAAAA,KAAK,GAAGjB,UAAU,CAACoB,UAAX,CAAsBV,IAAtB,CAA2BS,KAA3B,CAAR;;AAEA,YAAIF,KAAK,CAACI,QAAN,KAAmB,CAAvB,EAA0B;AACzB,cAAIlD,OAAO,CAACC,UAAZ,EAAwB;AACvBgC,YAAAA,aAAa,IAAIa,KAAK,CAACK,SAAvB;AACA,WAFD,MAEO;AACN,gBAAIpB,OAAO,CAACqB,cAAR,CAAuBpD,OAAO,CAACU,QAA/B,CAAJ,EAA8C;AAC7C,kBACCqB,OAAO,CAAC/B,OAAO,CAACU,QAAT,CAAP,CAA0B2C,WAA1B,KAA0CC,KAD3C,EAEE;AACDvB,gBAAAA,OAAO,CAAC/B,OAAO,CAACU,QAAT,CAAP,GAA4B,CAC3BqB,OAAO,CAAC/B,OAAO,CAACU,QAAT,CADoB,CAA5B;AAGA;;AACDqB,cAAAA,OAAO,CAAC/B,OAAO,CAACU,QAAT,CAAP,CAA0B6C,IAA1B,CAA+BT,KAAK,CAACK,SAArC;AACA,aATD,MASO;AACN,kBAAInD,OAAO,CAACc,eAAZ,EAA6B;AAC5BiB,gBAAAA,OAAO,CAAC/B,OAAO,CAACU,QAAT,CAAP,GAA4B,EAA5B;AACAqB,gBAAAA,OAAO,CAAC/B,OAAO,CAACU,QAAT,CAAP,CAA0B6C,IAA1B,CAA+BT,KAAK,CAACK,SAArC;AACA,eAHD,MAGO;AACNpB,gBAAAA,OAAO,CAAC/B,OAAO,CAACU,QAAT,CAAP,GAA4BoC,KAAK,CAACK,SAAlC;AACA;AACD;AACD;AACD;AAAC;AAtBF,aAsB4C,IAC3CL,KAAK,CAACI,QAAN,KAAmB,CADwB,EAE1C;AACDjB,YAAAA,aAAa,IAAIa,KAAK,CAACK,SAAvB;AACA;AAAC;AAJ0C,eAIR,IAAIL,KAAK,CAACI,QAAN,KAAmB,CAAvB,EAA0B;AAC7D;AAEA,kBAAIlB,OAAO,KAAK,CAAhB,EAAmB;AAClBD,gBAAAA,OAAO,GAAG,EAAV;AACA,eAL4D,CAO7D;;;AACA,kBAAI/B,OAAO,CAACa,eAAZ,EAA6B;AAC5BkC,gBAAAA,KAAK,GAAGD,KAAK,CAACU,QAAN,CAAeb,OAAf,CAAuB5B,WAAvB,EAAoC,EAApC,CAAR;AACA,eAFD,MAEO;AACNgC,gBAAAA,KAAK,GAAGD,KAAK,CAACU,QAAd;AACA;;AAEDhB,cAAAA,QAAQ,GAAG1C,SAAS,CAAC6B,QAAV,CAAmBmB,KAAnB,CAAX;;AAEA,kBAAIf,OAAO,CAACqB,cAAR,CAAuBL,KAAvB,CAAJ,EAAmC;AAClC,oBAAIhB,OAAO,CAACgB,KAAD,CAAP,CAAeM,WAAf,KAA+BC,KAAnC,EAA0C;AACzCvB,kBAAAA,OAAO,CAACgB,KAAD,CAAP,GAAiB,CAAChB,OAAO,CAACgB,KAAD,CAAR,CAAjB;AACA;;AACDhB,gBAAAA,OAAO,CAACgB,KAAD,CAAP,CAAeQ,IAAf,CAAoBf,QAApB;AACA,eALD,MAKO;AACN,oBAAIxC,OAAO,CAACc,eAAZ,EAA6B;AAC5BiB,kBAAAA,OAAO,CAACgB,KAAD,CAAP,GAAiB,EAAjB;AACAhB,kBAAAA,OAAO,CAACgB,KAAD,CAAP,CAAeQ,IAAf,CAAoBf,QAApB;AACA,iBAHD,MAGO;AACNT,kBAAAA,OAAO,CAACgB,KAAD,CAAP,GAAiBP,QAAjB;AACA;;AACDR,gBAAAA,OAAO;AACP;AACD;AACD;AACD,KAlED,MAkEO,IAAI,CAACC,aAAL,EAAoB;AAC1B;AACA,UAAIjC,OAAO,CAACc,eAAZ,EAA6B;AAC5BiB,QAAAA,OAAO,CAAC/B,OAAO,CAACO,OAAT,CAAP,GAA2B,EAA3B;AACAwB,QAAAA,OAAO,CAAC/B,OAAO,CAACO,OAAT,CAAP,CAAyBgD,IAAzB,CAA8B,IAA9B;AACA,OAHD,MAGO;AACNxB,QAAAA,OAAO,CAAC/B,OAAO,CAACO,OAAT,CAAP,GAA2B,IAA3B;AACA;AACD;;AAED,QAAI0B,aAAJ,EAAmB;AAClB,UAAIjC,OAAO,CAACG,QAAZ,EAAsB;AACrB,YAAIyC,KAAK,GAAG,KAAK1B,QAAL,CAAce,aAAa,CAACU,OAAd,CAAsB1B,SAAtB,EAAiC,EAAjC,CAAd,CAAZ;;AACA,YAAI2B,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKa,SAAhC,EAA2C;AAC1C1B,UAAAA,OAAO,CAAC/B,OAAO,CAACO,OAAT,CAAP,GAA2BqC,KAA3B;AACA;AACD,OALD,MAKO,IAAI5C,OAAO,CAACI,SAAZ,EAAuB;AAC7B2B,QAAAA,OAAO,CAAC/B,OAAO,CAACO,OAAT,CAAP,GAA2B0B,aAAa,CACtCU,OADyB,CACjB1B,SADiB,EACN,EADM,EAEzB0B,OAFyB,CAEjB,MAFiB,EAET,GAFS,CAA3B;AAGA,OAJM,MAIA;AACNZ,QAAAA,OAAO,CAAC/B,OAAO,CAACO,OAAT,CAAP,GAA2B0B,aAAa,CAACU,OAAd,CAAsB1B,SAAtB,EAAiC,EAAjC,CAA3B;AACA;AACD;;AAED,WAAOc,OAAP;AACA,GAzJD,CAzC0B,CAoM1B;AACA;;;AACA,OAAK2B,WAAL,GAAmB,UAASC,MAAT,EAAiB;AACnC,QAAI;AACH,UAAIlC,SAAS,GAAGkC,MAAM,CAACC,GAAP,GACbD,MAAM,CAACC,GADM,GAEb,IAAIC,aAAJ,GAAoBC,iBAApB,CAAsCH,MAAtC,CAFH;AAGA,aAAOlC,SAAP;AACA,KALD,CAKE,OAAOsC,GAAP,EAAY;AACb,aAAO,IAAP;AACA;AACD,GATD,CAtM0B,CAiN1B;AACA;;;AACA,OAAKnC,WAAL,GAAmB,UAASH,SAAT,EAAoB;AACtC,QAAI;AACH,UAAIkC,MAAM,GAAG,IAAb;;AAEA,UAAIK,MAAM,CAACC,SAAX,EAAsB;AACrB,YAAIC,MAAM,GAAG,IAAID,SAAJ,EAAb;AACAN,QAAAA,MAAM,GAAGO,MAAM,CAACC,eAAP,CAAuB1C,SAAvB,EAAkC,UAAlC,CAAT;AAEA,eAAOkC,MAAP;AACA,OALD,MAKO;AACN;AACAA,QAAAA,MAAM,CAACS,KAAP,GAAe,KAAf;AACAT,QAAAA,MAAM,CAACU,OAAP,CAAe5C,SAAf;AAEA,eAAOkC,MAAP;AACA;AACD,KAfD,CAeE,OAAOW,CAAP,EAAU;AACX,aAAO,IAAP;AACA;AACD,GAnBD;;AAqBA,SAAO,IAAP;AACA,CAzOe,CAyOdC,IAzOc,CAyOT,EAzOS,CAAhB;;AA2OA,IAAI,OAAOC,MAAP,IAAiB,WAAjB,IAAgCA,MAAM,KAAK,IAA3C,IAAmDA,MAAM,CAACC,OAA9D,EACCD,MAAM,CAACC,OAAP,GAAiB3E,SAAjB","sourcesContent":["/* Copyright 2015 William Summers, MetaTribal LLC\n * adapted from https://developer.mozilla.org/en-US/docs/JXON\n *\n * Licensed under the MIT License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/MIT\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @author William Summers\n *\n */\n\nvar xmlToJSON = function() {\n\tthis.version = \"1.3.4\";\n\n\tvar options = {\n\t\t// set up the default options\n\t\tmergeCDATA: true, // extract cdata and merge with text\n\t\tgrokAttr: true, // convert truthy attributes to boolean, etc\n\t\tgrokText: true, // convert truthy text/attr to boolean, etc\n\t\tnormalize: true, // collapse multiple spaces to single space\n\t\txmlns: true, // include namespaces as attribute in output\n\t\tnamespaceKey: \"_ns\", // tag name for namespace objects\n\t\ttextKey: \"_text\", // tag name for text nodes\n\t\tvalueKey: \"_value\", // tag name for attribute values\n\t\tattrKey: \"_attr\", // tag for attr groups\n\t\tcdataKey: \"_cdata\", // tag for cdata nodes (ignored if mergeCDATA is true)\n\t\tattrsAsObject: true, // if false, key is used as prefix to name, set prefix to '' to merge children and attrs.\n\t\tstripAttrPrefix: true, // remove namespace prefixes from attributes\n\t\tstripElemPrefix: true, // for elements of same name in diff namespaces, you can enable namespaces and access the nskey property\n\t\tchildrenAsArray: true // force children into arrays\n\t};\n\n\tvar prefixMatch = new RegExp(/(?!xmlns)^.*:/);\n\tvar trimMatch = new RegExp(/^\\s+|\\s+$/g);\n\n\tthis.grokType = function(sValue) {\n\t\tif (/^\\s*$/.test(sValue)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (/^(?:true|false)$/i.test(sValue)) {\n\t\t\treturn sValue.toLowerCase() === \"true\";\n\t\t}\n\t\tif (isFinite(sValue)) {\n\t\t\treturn parseFloat(sValue);\n\t\t}\n\t\treturn sValue;\n\t};\n\n\tthis.parseString = function(xmlString, opt) {\n\t\treturn this.parseXML(this.stringToXML(xmlString), opt);\n\t};\n\n\tthis.parseXML = function(oXMLParent, opt) {\n\t\t// initialize options\n\t\tfor (var key in opt) {\n\t\t\toptions[key] = opt[key];\n\t\t}\n\n\t\tvar vResult = {},\n\t\t\tnLength = 0,\n\t\t\tsCollectedTxt = \"\";\n\n\t\t// parse namespace information\n\t\tif (options.xmlns && oXMLParent.namespaceURI) {\n\t\t\tvResult[options.namespaceKey] = oXMLParent.namespaceURI;\n\t\t}\n\n\t\t// parse attributes\n\t\t// using attributes property instead of hasAttributes method to support older browsers\n\t\tif (oXMLParent.attributes && oXMLParent.attributes.length > 0) {\n\t\t\tvar vAttribs = {};\n\n\t\t\tfor (nLength; nLength < oXMLParent.attributes.length; nLength++) {\n\t\t\t\tvar oAttrib = oXMLParent.attributes.item(nLength);\n\t\t\t\tvar vContent = {};\n\t\t\t\tvar attribName = \"\";\n\n\t\t\t\tif (options.stripAttrPrefix) {\n\t\t\t\t\tattribName = oAttrib.name.replace(prefixMatch, \"\");\n\t\t\t\t} else {\n\t\t\t\t\tattribName = oAttrib.name;\n\t\t\t\t}\n\n\t\t\t\tif (options.grokAttr) {\n\t\t\t\t\tvContent[options.valueKey] = this.grokType(\n\t\t\t\t\t\toAttrib.value.replace(trimMatch, \"\")\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tvContent[options.valueKey] = oAttrib.value.replace(\n\t\t\t\t\t\ttrimMatch,\n\t\t\t\t\t\t\"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (options.xmlns && oAttrib.namespaceURI) {\n\t\t\t\t\tvContent[options.namespaceKey] = oAttrib.namespaceURI;\n\t\t\t\t}\n\n\t\t\t\tif (options.attrsAsObject) {\n\t\t\t\t\t// attributes with same local name must enable prefixes\n\t\t\t\t\tvAttribs[attribName] = vContent;\n\t\t\t\t} else {\n\t\t\t\t\tvResult[options.attrKey + attribName] = vContent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (options.attrsAsObject) {\n\t\t\t\tvResult[options.attrKey] = vAttribs;\n\t\t\t} else {\n\t\t\t}\n\t\t}\n\n\t\t// iterate over the children\n\t\tif (oXMLParent.hasChildNodes()) {\n\t\t\tfor (\n\t\t\t\tvar oNode, sProp, nItem = 0;\n\t\t\t\tnItem < oXMLParent.childNodes.length;\n\t\t\t\tnItem++\n\t\t\t) {\n\t\t\t\toNode = oXMLParent.childNodes.item(nItem);\n\n\t\t\t\tif (oNode.nodeType === 4) {\n\t\t\t\t\tif (options.mergeCDATA) {\n\t\t\t\t\t\tsCollectedTxt += oNode.nodeValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (vResult.hasOwnProperty(options.cdataKey)) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tvResult[options.cdataKey].constructor !== Array\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tvResult[options.cdataKey] = [\n\t\t\t\t\t\t\t\t\tvResult[options.cdataKey]\n\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvResult[options.cdataKey].push(oNode.nodeValue);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (options.childrenAsArray) {\n\t\t\t\t\t\t\t\tvResult[options.cdataKey] = [];\n\t\t\t\t\t\t\t\tvResult[options.cdataKey].push(oNode.nodeValue);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvResult[options.cdataKey] = oNode.nodeValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} /* nodeType is \"CDATASection\" (4) */ else if (\n\t\t\t\t\toNode.nodeType === 3\n\t\t\t\t) {\n\t\t\t\t\tsCollectedTxt += oNode.nodeValue;\n\t\t\t\t} /* nodeType is \"Text\" (3) */ else if (oNode.nodeType === 1) {\n\t\t\t\t\t/* nodeType is \"Element\" (1) */\n\n\t\t\t\t\tif (nLength === 0) {\n\t\t\t\t\t\tvResult = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// using nodeName to support browser (IE) implementation with no 'localName' property\n\t\t\t\t\tif (options.stripElemPrefix) {\n\t\t\t\t\t\tsProp = oNode.nodeName.replace(prefixMatch, \"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsProp = oNode.nodeName;\n\t\t\t\t\t}\n\n\t\t\t\t\tvContent = xmlToJSON.parseXML(oNode);\n\n\t\t\t\t\tif (vResult.hasOwnProperty(sProp)) {\n\t\t\t\t\t\tif (vResult[sProp].constructor !== Array) {\n\t\t\t\t\t\t\tvResult[sProp] = [vResult[sProp]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvResult[sProp].push(vContent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (options.childrenAsArray) {\n\t\t\t\t\t\t\tvResult[sProp] = [];\n\t\t\t\t\t\t\tvResult[sProp].push(vContent);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvResult[sProp] = vContent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnLength++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!sCollectedTxt) {\n\t\t\t// no children and no text, return null\n\t\t\tif (options.childrenAsArray) {\n\t\t\t\tvResult[options.textKey] = [];\n\t\t\t\tvResult[options.textKey].push(null);\n\t\t\t} else {\n\t\t\t\tvResult[options.textKey] = null;\n\t\t\t}\n\t\t}\n\n\t\tif (sCollectedTxt) {\n\t\t\tif (options.grokText) {\n\t\t\t\tvar value = this.grokType(sCollectedTxt.replace(trimMatch, \"\"));\n\t\t\t\tif (value !== null && value !== undefined) {\n\t\t\t\t\tvResult[options.textKey] = value;\n\t\t\t\t}\n\t\t\t} else if (options.normalize) {\n\t\t\t\tvResult[options.textKey] = sCollectedTxt\n\t\t\t\t\t.replace(trimMatch, \"\")\n\t\t\t\t\t.replace(/\\s+/g, \" \");\n\t\t\t} else {\n\t\t\t\tvResult[options.textKey] = sCollectedTxt.replace(trimMatch, \"\");\n\t\t\t}\n\t\t}\n\n\t\treturn vResult;\n\t};\n\n\t// Convert xmlDocument to a string\n\t// Returns null on failure\n\tthis.xmlToString = function(xmlDoc) {\n\t\ttry {\n\t\t\tvar xmlString = xmlDoc.xml\n\t\t\t\t? xmlDoc.xml\n\t\t\t\t: new XMLSerializer().serializeToString(xmlDoc);\n\t\t\treturn xmlString;\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t// Convert a string to XML Node Structure\n\t// Returns null on failure\n\tthis.stringToXML = function(xmlString) {\n\t\ttry {\n\t\t\tvar xmlDoc = null;\n\n\t\t\tif (window.DOMParser) {\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\txmlDoc = parser.parseFromString(xmlString, \"text/xml\");\n\n\t\t\t\treturn xmlDoc;\n\t\t\t} else {\n\t\t\t\t//xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n\t\t\t\txmlDoc.async = false;\n\t\t\t\txmlDoc.loadXML(xmlString);\n\n\t\t\t\treturn xmlDoc;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\treturn null;\n\t\t}\n\t};\n\n\treturn this;\n}.call({});\n\nif (typeof module != \"undefined\" && module !== null && module.exports)\n\tmodule.exports = xmlToJSON;\n"]},"metadata":{},"sourceType":"script"}